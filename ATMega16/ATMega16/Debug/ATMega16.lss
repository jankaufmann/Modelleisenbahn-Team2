
ATMega16.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000610  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  000006b0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000124  00800060  00800060  000006a4  2**0
                  ALLOC
  3 .eeprom       0000000c  00810000  00810000  000006a4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      00000030  00000000  00000000  000006b0  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000006e0  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000238  00000000  00000000  0000071c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000060b2  00000000  00000000  00000954  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000f31  00000000  00000000  00006a06  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000025bb  00000000  00000000  00007937  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000005e0  00000000  00000000  00009ef4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00009604  00000000  00000000  0000a4d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001678  00000000  00000000  00013ad8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000200  00000000  00000000  00015150  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_macro  000032db  00000000  00000000  00015350  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	29 c0       	rjmp	.+82     	; 0x54 <__ctors_end>
   2:	00 00       	nop
   4:	42 c0       	rjmp	.+132    	; 0x8a <__bad_interrupt>
   6:	00 00       	nop
   8:	4e c0       	rjmp	.+156    	; 0xa6 <__vector_2>
   a:	00 00       	nop
   c:	3e c0       	rjmp	.+124    	; 0x8a <__bad_interrupt>
   e:	00 00       	nop
  10:	3c c0       	rjmp	.+120    	; 0x8a <__bad_interrupt>
  12:	00 00       	nop
  14:	84 c0       	rjmp	.+264    	; 0x11e <__vector_5>
  16:	00 00       	nop
  18:	ac c0       	rjmp	.+344    	; 0x172 <__vector_6>
  1a:	00 00       	nop
  1c:	36 c0       	rjmp	.+108    	; 0x8a <__bad_interrupt>
  1e:	00 00       	nop
  20:	34 c0       	rjmp	.+104    	; 0x8a <__bad_interrupt>
  22:	00 00       	nop
  24:	93 c2       	rjmp	.+1318   	; 0x54c <__vector_9>
  26:	00 00       	nop
  28:	30 c0       	rjmp	.+96     	; 0x8a <__bad_interrupt>
  2a:	00 00       	nop
  2c:	2e c0       	rjmp	.+92     	; 0x8a <__bad_interrupt>
  2e:	00 00       	nop
  30:	2c c0       	rjmp	.+88     	; 0x8a <__bad_interrupt>
  32:	00 00       	nop
  34:	2a c0       	rjmp	.+84     	; 0x8a <__bad_interrupt>
  36:	00 00       	nop
  38:	28 c0       	rjmp	.+80     	; 0x8a <__bad_interrupt>
  3a:	00 00       	nop
  3c:	26 c0       	rjmp	.+76     	; 0x8a <__bad_interrupt>
  3e:	00 00       	nop
  40:	24 c0       	rjmp	.+72     	; 0x8a <__bad_interrupt>
  42:	00 00       	nop
  44:	22 c0       	rjmp	.+68     	; 0x8a <__bad_interrupt>
  46:	00 00       	nop
  48:	20 c0       	rjmp	.+64     	; 0x8a <__bad_interrupt>
  4a:	00 00       	nop
  4c:	1e c0       	rjmp	.+60     	; 0x8a <__bad_interrupt>
  4e:	00 00       	nop
  50:	1c c0       	rjmp	.+56     	; 0x8a <__bad_interrupt>
	...

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e0 e1       	ldi	r30, 0x10	; 16
  68:	f6 e0       	ldi	r31, 0x06	; 6
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a0 36       	cpi	r26, 0x60	; 96
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	21 e0       	ldi	r18, 0x01	; 1
  78:	a0 e6       	ldi	r26, 0x60	; 96
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a4 38       	cpi	r26, 0x84	; 132
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	3c d0       	rcall	.+120    	; 0x100 <main>
  88:	c1 c2       	rjmp	.+1410   	; 0x60c <_exit>

0000008a <__bad_interrupt>:
  8a:	ba cf       	rjmp	.-140    	; 0x0 <__vectors>

0000008c <setLEDasOutput>:
  slotArray[3].adr2      = 0;                        /* loco address high                                    */
  slotArray[3].snd       = 0;                        /* Sound 1-4 / F5-F8                                    */
  slotArray[3].dirKey	  = DIRKEY4;
  slotArray[3].funKey	  = FUNKEY4;
  slotArray[3].ledAdr	  = LED4;
  slotArray[3].ledPort   = PORTC;
  8c:	d0 9a       	sbi	0x1a, 0	; 26
  8e:	d1 9a       	sbi	0x1a, 1	; 26
  90:	a3 9a       	sbi	0x14, 3	; 20
  92:	a4 9a       	sbi	0x14, 4	; 20
  94:	08 95       	ret

00000096 <enableLED1>:
  96:	d8 9a       	sbi	0x1b, 0	; 27
  98:	08 95       	ret

0000009a <enableLED2>:
  9a:	d9 9a       	sbi	0x1b, 1	; 27
  9c:	08 95       	ret

0000009e <enableLED3>:
  9e:	ab 9a       	sbi	0x15, 3	; 21
  a0:	08 95       	ret

000000a2 <disableLED4>:
  a2:	ac 98       	cbi	0x15, 4	; 21
  a4:	08 95       	ret

000000a6 <__vector_2>:
  a6:	1f 92       	push	r1
  a8:	0f 92       	push	r0
  aa:	0f b6       	in	r0, 0x3f	; 63
  ac:	0f 92       	push	r0
  ae:	11 24       	eor	r1, r1
  b0:	8f 93       	push	r24
  b2:	8b b7       	in	r24, 0x3b	; 59
  b4:	8f 77       	andi	r24, 0x7F	; 127
  b6:	8b bf       	out	0x3b, r24	; 59
  b8:	05 b6       	in	r0, 0x35	; 53
  ba:	02 fe       	sbrs	r0, 2
  bc:	0e c0       	rjmp	.+28     	; 0xda <__vector_2+0x34>
  be:	82 9b       	sbis	0x10, 2	; 16
  c0:	06 c0       	rjmp	.+12     	; 0xce <__vector_2+0x28>
  c2:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_end>
  c6:	81 50       	subi	r24, 0x01	; 1
  c8:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_end>
  cc:	13 c0       	rjmp	.+38     	; 0xf4 <__vector_2+0x4e>
  ce:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_end>
  d2:	8f 5f       	subi	r24, 0xFF	; 255
  d4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_end>
  d8:	0d c0       	rjmp	.+26     	; 0xf4 <__vector_2+0x4e>
  da:	82 9b       	sbis	0x10, 2	; 16
  dc:	06 c0       	rjmp	.+12     	; 0xea <__vector_2+0x44>
  de:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_end>
  e2:	8f 5f       	subi	r24, 0xFF	; 255
  e4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_end>
  e8:	05 c0       	rjmp	.+10     	; 0xf4 <__vector_2+0x4e>
  ea:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_end>
  ee:	81 50       	subi	r24, 0x01	; 1
  f0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_end>
  f4:	8f 91       	pop	r24
  f6:	0f 90       	pop	r0
  f8:	0f be       	out	0x3f, r0	; 63
  fa:	0f 90       	pop	r0
  fc:	1f 90       	pop	r1
  fe:	18 95       	reti

00000100 <main>:
//
int8_t test = 0;
uint8_t statusLED = 1;
ADCSRA = (0<<ADEN);
setLEDasOutput();
enableLED1();
 100:	16 b8       	out	0x06, r1	; 6
 102:	c4 df       	rcall	.-120    	; 0x8c <setLEDasOutput>
 104:	c8 df       	rcall	.-112    	; 0x96 <enableLED1>
 106:	c9 df       	rcall	.-110    	; 0x9a <enableLED2>
 108:	ca df       	rcall	.-108    	; 0x9e <enableLED3>
 10a:	cb df       	rcall	.-106    	; 0xa2 <disableLED4>
 10c:	86 e8       	ldi	r24, 0x86	; 134
 10e:	90 e0       	ldi	r25, 0x00	; 0
 110:	5d d2       	rcall	.+1210   	; 0x5cc <initLocoNet>
 112:	29 e1       	ldi	r18, 0x19	; 25
 114:	43 e4       	ldi	r20, 0x43	; 67
 116:	65 e0       	ldi	r22, 0x05	; 5
 118:	80 ea       	ldi	r24, 0xA0	; 160
 11a:	5e d2       	rcall	.+1212   	; 0x5d8 <sendLocoNet4BytePacketTry>
 11c:	ff cf       	rjmp	.-2      	; 0x11c <main+0x1c>

0000011e <__vector_5>:
* incoming data.
*
**************************************************************************/

ISR(LN_SB_SIGNAL)
{
 11e:	1f 92       	push	r1
 120:	0f 92       	push	r0
 122:	0f b6       	in	r0, 0x3f	; 63
 124:	0f 92       	push	r0
 126:	11 24       	eor	r1, r1
 128:	8f 93       	push	r24
 12a:	9f 93       	push	r25
    // Disable the Input Comparator Interrupt
  cbi( LN_SB_INT_ENABLE_REG, LN_SB_INT_ENABLE_BIT );     
 12c:	89 b7       	in	r24, 0x39	; 57
 12e:	8f 7d       	andi	r24, 0xDF	; 223
 130:	89 bf       	out	0x39, r24	; 57
#ifdef RX_MONITOR
  cbi(PORTD, PD1);
#endif

    // Get the Current Timer1 Count and Add the offset for the Compare target
  lnCompareTarget = LN_TMR_INP_CAPT_REG + LN_TIMER_RX_START_PERIOD ;
 132:	86 b5       	in	r24, 0x26	; 38
 134:	97 b5       	in	r25, 0x27	; 39
 136:	80 56       	subi	r24, 0x60	; 96
 138:	9a 4f       	sbci	r25, 0xFA	; 250
 13a:	90 93 7d 01 	sts	0x017D, r25	; 0x80017d <lnCompareTarget+0x1>
 13e:	80 93 7c 01 	sts	0x017C, r24	; 0x80017c <lnCompareTarget>
  LN_TMR_OUTP_CAPT_REG = lnCompareTarget ;
 142:	80 91 7c 01 	lds	r24, 0x017C	; 0x80017c <lnCompareTarget>
 146:	90 91 7d 01 	lds	r25, 0x017D	; 0x80017d <lnCompareTarget+0x1>
 14a:	9b bd       	out	0x2b, r25	; 43
 14c:	8a bd       	out	0x2a, r24	; 42

    // Clear the current Compare interrupt status bit and enable the Compare interrupt
  sbi(LN_TMR_INT_STATUS_REG, LN_TMR_INT_STATUS_BIT) ;
 14e:	88 b7       	in	r24, 0x38	; 56
 150:	80 61       	ori	r24, 0x10	; 16
 152:	88 bf       	out	0x38, r24	; 56
  sbi(LN_TMR_INT_ENABLE_REG, LN_TMR_INT_ENABLE_BIT) ; 
 154:	89 b7       	in	r24, 0x39	; 57
 156:	80 61       	ori	r24, 0x10	; 16
 158:	89 bf       	out	0x39, r24	; 57

    // Set the State to indicate that we have begun to Receive
  lnState = LN_ST_RX ;
 15a:	84 e0       	ldi	r24, 0x04	; 4
 15c:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <lnState>

    // Reset the bit counter so that on first increment it is on 0
  lnBitCount = 0;
 160:	10 92 81 01 	sts	0x0181, r1	; 0x800181 <lnBitCount>
}
 164:	9f 91       	pop	r25
 166:	8f 91       	pop	r24
 168:	0f 90       	pop	r0
 16a:	0f be       	out	0x3f, r0	; 63
 16c:	0f 90       	pop	r0
 16e:	1f 90       	pop	r1
 170:	18 95       	reti

00000172 <__vector_6>:
* it samples the bit and shifts it into the buffer.
*
**************************************************************************/

ISR(LN_TMR_SIGNAL)     /* signal handler for timer0 overflow */
{
 172:	1f 92       	push	r1
 174:	0f 92       	push	r0
 176:	0f b6       	in	r0, 0x3f	; 63
 178:	0f 92       	push	r0
 17a:	11 24       	eor	r1, r1
 17c:	0f 93       	push	r16
 17e:	1f 93       	push	r17
 180:	2f 93       	push	r18
 182:	3f 93       	push	r19
 184:	4f 93       	push	r20
 186:	5f 93       	push	r21
 188:	6f 93       	push	r22
 18a:	7f 93       	push	r23
 18c:	8f 93       	push	r24
 18e:	9f 93       	push	r25
 190:	af 93       	push	r26
 192:	bf 93       	push	r27
 194:	cf 93       	push	r28
 196:	df 93       	push	r29
 198:	ef 93       	push	r30
 19a:	ff 93       	push	r31
    // Advance the Compare Target
  lnCompareTarget += LN_TIMER_RX_RELOAD_PERIOD ;
 19c:	80 91 7c 01 	lds	r24, 0x017C	; 0x80017c <lnCompareTarget>
 1a0:	90 91 7d 01 	lds	r25, 0x017D	; 0x80017d <lnCompareTarget+0x1>
 1a4:	80 54       	subi	r24, 0x40	; 64
 1a6:	9c 4f       	sbci	r25, 0xFC	; 252
 1a8:	90 93 7d 01 	sts	0x017D, r25	; 0x80017d <lnCompareTarget+0x1>
 1ac:	80 93 7c 01 	sts	0x017C, r24	; 0x80017c <lnCompareTarget>
  LN_TMR_OUTP_CAPT_REG = lnCompareTarget ;
 1b0:	80 91 7c 01 	lds	r24, 0x017C	; 0x80017c <lnCompareTarget>
 1b4:	90 91 7d 01 	lds	r25, 0x017D	; 0x80017d <lnCompareTarget+0x1>
 1b8:	9b bd       	out	0x2b, r25	; 43
 1ba:	8a bd       	out	0x2a, r24	; 42

  lnBitCount++;                         //Increment bit_counter
 1bc:	80 91 81 01 	lds	r24, 0x0181	; 0x800181 <lnBitCount>
 1c0:	8f 5f       	subi	r24, 0xFF	; 255
 1c2:	80 93 81 01 	sts	0x0181, r24	; 0x800181 <lnBitCount>

    // Are we in the RX State
  if( lnState == LN_ST_RX )                // Are we in RX mode
 1c6:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <lnState>
 1ca:	84 30       	cpi	r24, 0x04	; 4
 1cc:	09 f0       	breq	.+2      	; 0x1d0 <__vector_6+0x5e>
 1ce:	3f c0       	rjmp	.+126    	; 0x24e <__vector_6+0xdc>
  {
    if( lnBitCount < 9)               // Are we in the Stop Bits phase
 1d0:	80 91 81 01 	lds	r24, 0x0181	; 0x800181 <lnBitCount>
 1d4:	89 30       	cpi	r24, 0x09	; 9
 1d6:	68 f4       	brcc	.+26     	; 0x1f2 <__vector_6+0x80>
    {
      lnCurrentByte >>= 1;
 1d8:	80 91 7b 01 	lds	r24, 0x017B	; 0x80017b <lnCurrentByte>
 1dc:	86 95       	lsr	r24
 1de:	80 93 7b 01 	sts	0x017B, r24	; 0x80017b <lnCurrentByte>
#ifdef LN_SW_UART_RX_INVERTED
      if( bit_is_clear(LN_RX_PORT, LN_RX_BIT))
#else
      if( bit_is_set(LN_RX_PORT, LN_RX_BIT))
 1e2:	45 9b       	sbis	0x08, 5	; 8
 1e4:	eb c0       	rjmp	.+470    	; 0x3bc <__vector_6+0x24a>
#endif

        lnCurrentByte |= 0x80;
 1e6:	80 91 7b 01 	lds	r24, 0x017B	; 0x80017b <lnCurrentByte>
 1ea:	80 68       	ori	r24, 0x80	; 128
 1ec:	80 93 7b 01 	sts	0x017B, r24	; 0x80017b <lnCurrentByte>
 1f0:	e5 c0       	rjmp	.+458    	; 0x3bc <__vector_6+0x24a>
      return ;
    }

      // Clear the Start Bit Interrupt Status Flag and Enable ready to 
      // detect the next Start Bit
    sbi( LN_SB_INT_STATUS_REG, LN_SB_INT_STATUS_BIT ) ;
 1f2:	88 b7       	in	r24, 0x38	; 56
 1f4:	80 62       	ori	r24, 0x20	; 32
 1f6:	88 bf       	out	0x38, r24	; 56
    sbi( LN_SB_INT_ENABLE_REG, LN_SB_INT_ENABLE_BIT ) ;
 1f8:	89 b7       	in	r24, 0x39	; 57
 1fa:	80 62       	ori	r24, 0x20	; 32
 1fc:	89 bf       	out	0x39, r24	; 57

      // If the Stop bit is not Set then we have a Framing Error
#ifdef LN_SW_UART_RX_INVERTED
    if( bit_is_set(LN_RX_PORT,LN_RX_BIT) )
#else
    if( bit_is_clear(LN_RX_PORT,LN_RX_BIT) )
 1fe:	45 99       	sbic	0x08, 5	; 8
 200:	0a c0       	rjmp	.+20     	; 0x216 <__vector_6+0xa4>
#endif
      lnRxBuffer->Stats.RxErrors++ ;
 202:	e0 91 7e 01 	lds	r30, 0x017E	; 0x80017e <lnRxBuffer>
 206:	f0 91 7f 01 	lds	r31, 0x017F	; 0x80017f <lnRxBuffer+0x1>
 20a:	e9 57       	subi	r30, 0x79	; 121
 20c:	ff 4f       	sbci	r31, 0xFF	; 255
 20e:	80 81       	ld	r24, Z
 210:	8f 5f       	subi	r24, 0xFF	; 255
 212:	80 83       	st	Z, r24
 214:	17 c0       	rjmp	.+46     	; 0x244 <__vector_6+0xd2>

    else
        // Put the received byte in the buffer
      addByteLnBuf( lnRxBuffer, lnCurrentByte ) ;
 216:	40 91 7b 01 	lds	r20, 0x017B	; 0x80017b <lnCurrentByte>
 21a:	80 91 7e 01 	lds	r24, 0x017E	; 0x80017e <lnRxBuffer>
 21e:	90 91 7f 01 	lds	r25, 0x017F	; 0x80017f <lnRxBuffer+0x1>
void addByteLnBuf( LnBuf *Buffer, byte newByte );
void addMsgLnBuf( LnBuf *Buffer, volatile lnMsg * newMsg );
#else
static inline void addByteLnBuf( LnBuf *Buffer, byte newByte )
{
	Buffer->Buf[ Buffer->WriteIndex++ ] = newByte ;
 222:	fc 01       	movw	r30, r24
 224:	e0 58       	subi	r30, 0x80	; 128
 226:	ff 4f       	sbci	r31, 0xFF	; 255
 228:	30 81       	ld	r19, Z
 22a:	21 e0       	ldi	r18, 0x01	; 1
 22c:	23 0f       	add	r18, r19
 22e:	20 83       	st	Z, r18
 230:	fc 01       	movw	r30, r24
 232:	e3 0f       	add	r30, r19
 234:	f1 1d       	adc	r31, r1
 236:	40 83       	st	Z, r20
	if( Buffer->WriteIndex >= LN_BUF_SIZE )
 238:	22 23       	and	r18, r18
 23a:	24 f4       	brge	.+8      	; 0x244 <__vector_6+0xd2>
		Buffer->WriteIndex = 0 ;
 23c:	fc 01       	movw	r30, r24
 23e:	e0 58       	subi	r30, 0x80	; 128
 240:	ff 4f       	sbci	r31, 0xFF	; 255
 242:	10 82       	st	Z, r1

    lnBitCount = 0 ;
 244:	10 92 81 01 	sts	0x0181, r1	; 0x800181 <lnBitCount>
    lnState = LN_ST_CD_BACKOFF ;
 248:	81 e0       	ldi	r24, 0x01	; 1
 24a:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <lnState>
  }


    // Are we in the TX State
  if( lnState == LN_ST_TX )
 24e:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <lnState>
 252:	83 30       	cpi	r24, 0x03	; 3
 254:	09 f0       	breq	.+2      	; 0x258 <__vector_6+0xe6>
 256:	7d c0       	rjmp	.+250    	; 0x352 <__vector_6+0x1e0>
  #endif
#else  // inverted is the normal case, just a NPN between TX pin and LN:
  #ifdef LN_SW_UART_RX_INVERTED
    if( ( ( LN_TX_PORT >> LN_TX_BIT ) & 0x01 ) != ( ( LN_RX_PORT >> LN_RX_BIT ) & 0x01 ) )
  #else
    if( ( ( LN_TX_PORT >> LN_TX_BIT ) & 0x01 ) == ( ( LN_RX_PORT >> LN_RX_BIT ) & 0x01 ) )
 258:	98 b3       	in	r25, 0x18	; 24
 25a:	88 b1       	in	r24, 0x08	; 8
 25c:	96 95       	lsr	r25
 25e:	82 95       	swap	r24
 260:	86 95       	lsr	r24
 262:	87 70       	andi	r24, 0x07	; 7
 264:	89 27       	eor	r24, r25
 266:	80 fd       	sbrc	r24, 0
 268:	06 c0       	rjmp	.+12     	; 0x276 <__vector_6+0x104>
  #endif
#endif
    {
      lnBitCount = 0 ;
 26a:	10 92 81 01 	sts	0x0181, r1	; 0x800181 <lnBitCount>
      lnState = LN_ST_TX_COLLISION ;
 26e:	82 e0       	ldi	r24, 0x02	; 2
 270:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <lnState>
 274:	6e c0       	rjmp	.+220    	; 0x352 <__vector_6+0x1e0>
    }
      // Send each Bit
    else if( lnBitCount < 9)
 276:	80 91 81 01 	lds	r24, 0x0181	; 0x800181 <lnBitCount>
 27a:	89 30       	cpi	r24, 0x09	; 9
 27c:	68 f4       	brcc	.+26     	; 0x298 <__vector_6+0x126>
    {
#ifdef TX_START_MEASUREMENT
			cbi(TX_MEASUREMENT_PORT, TX_MEASUREMENT_PIN);
#endif
			
      if( lnCurrentByte & 0x01 )
 27e:	80 91 7b 01 	lds	r24, 0x017B	; 0x80017b <lnCurrentByte>
 282:	80 ff       	sbrs	r24, 0
 284:	02 c0       	rjmp	.+4      	; 0x28a <__vector_6+0x118>
        LN_SW_UART_SET_TX_HIGH
 286:	c1 98       	cbi	0x18, 1	; 24
 288:	01 c0       	rjmp	.+2      	; 0x28c <__vector_6+0x11a>

      else
        LN_SW_UART_SET_TX_LOW
 28a:	c1 9a       	sbi	0x18, 1	; 24

      lnCurrentByte >>= 1;
 28c:	80 91 7b 01 	lds	r24, 0x017B	; 0x80017b <lnCurrentByte>
 290:	86 95       	lsr	r24
 292:	80 93 7b 01 	sts	0x017B, r24	; 0x80017b <lnCurrentByte>
 296:	5d c0       	rjmp	.+186    	; 0x352 <__vector_6+0x1e0>
    }
      // When the Data Bits are done, generate stop-bit
    else if( lnBitCount ==  9)
 298:	80 91 81 01 	lds	r24, 0x0181	; 0x800181 <lnBitCount>
 29c:	89 30       	cpi	r24, 0x09	; 9
 29e:	11 f4       	brne	.+4      	; 0x2a4 <__vector_6+0x132>
      LN_SW_UART_SET_TX_HIGH
 2a0:	c1 98       	cbi	0x18, 1	; 24
 2a2:	57 c0       	rjmp	.+174    	; 0x352 <__vector_6+0x1e0>

      // Any more bytes in buffer
    else if( ++lnTxIndex < lnTxLength )
 2a4:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <lnTxIndex>
 2a8:	8f 5f       	subi	r24, 0xFF	; 255
 2aa:	80 93 79 01 	sts	0x0179, r24	; 0x800179 <lnTxIndex>
 2ae:	90 91 7a 01 	lds	r25, 0x017A	; 0x80017a <lnTxLength>
 2b2:	89 17       	cp	r24, r25
 2b4:	e8 f4       	brcc	.+58     	; 0x2f0 <__vector_6+0x17e>
    {
        // Setup for the next byte
      lnBitCount = 0 ;
 2b6:	10 92 81 01 	sts	0x0181, r1	; 0x800181 <lnBitCount>
      lnCurrentByte = lnTxData->data[ lnTxIndex ] ;
 2ba:	e0 91 82 01 	lds	r30, 0x0182	; 0x800182 <lnTxData>
 2be:	f0 91 83 01 	lds	r31, 0x0183	; 0x800183 <lnTxData+0x1>
 2c2:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <lnTxIndex>
 2c6:	e8 0f       	add	r30, r24
 2c8:	f1 1d       	adc	r31, r1
 2ca:	80 81       	ld	r24, Z
 2cc:	80 93 7b 01 	sts	0x017B, r24	; 0x80017b <lnCurrentByte>

        // Begin the Start Bit
      LN_SW_UART_SET_TX_LOW
 2d0:	c1 9a       	sbi	0x18, 1	; 24
			sbi(TX_MEASUREMENT_PORT, TX_MEASUREMENT_PIN);
#endif

        // Get the Current Timer1 Count and Add the offset for the Compare target
        // added adjustment value for bugfix (Olaf Funke)
      lnCompareTarget = LN_TMR_COUNT_REG + LN_TIMER_TX_RELOAD_PERIOD - LN_TIMER_TX_RELOAD_ADJUST; 
 2d2:	8c b5       	in	r24, 0x2c	; 44
 2d4:	9d b5       	in	r25, 0x2d	; 45
 2d6:	85 51       	subi	r24, 0x15	; 21
 2d8:	9d 4f       	sbci	r25, 0xFD	; 253
 2da:	90 93 7d 01 	sts	0x017D, r25	; 0x80017d <lnCompareTarget+0x1>
 2de:	80 93 7c 01 	sts	0x017C, r24	; 0x80017c <lnCompareTarget>
      LN_TMR_OUTP_CAPT_REG = lnCompareTarget ;
 2e2:	80 91 7c 01 	lds	r24, 0x017C	; 0x80017c <lnCompareTarget>
 2e6:	90 91 7d 01 	lds	r25, 0x017D	; 0x80017d <lnCompareTarget+0x1>
 2ea:	9b bd       	out	0x2b, r25	; 43
 2ec:	8a bd       	out	0x2a, r24	; 42
 2ee:	31 c0       	rjmp	.+98     	; 0x352 <__vector_6+0x1e0>
    }
    else
    {
        // Successfully Sent all bytes in the buffer
        // so set the Packet Status to Done
      lnTxSuccess = 1 ;
 2f0:	81 e0       	ldi	r24, 0x01	; 1
 2f2:	80 93 78 01 	sts	0x0178, r24	; 0x800178 <lnTxSuccess>

        // Now copy the TX Packet into the RX Buffer
      addMsgLnBuf( lnRxBuffer, lnTxData );
 2f6:	c0 91 82 01 	lds	r28, 0x0182	; 0x800182 <lnTxData>
 2fa:	d0 91 83 01 	lds	r29, 0x0183	; 0x800183 <lnTxData+0x1>
 2fe:	00 91 7e 01 	lds	r16, 0x017E	; 0x80017e <lnRxBuffer>
 302:	10 91 7f 01 	lds	r17, 0x017F	; 0x80017f <lnRxBuffer+0x1>
static inline void addMsgLnBuf( LnBuf *Buffer, volatile lnMsg * newMsg )
{
	byte	Index ;
	byte 	Length ;

	Length = getLnMsgSize( newMsg ) ;
 306:	ce 01       	movw	r24, r28
 308:	54 d1       	rcall	.+680    	; 0x5b2 <getLnMsgSize>
	for( Index = 0; Index < Length; Index++ )
 30a:	88 23       	and	r24, r24
 30c:	e9 f0       	breq	.+58     	; 0x348 <__vector_6+0x1d6>
 30e:	81 50       	subi	r24, 0x01	; 1
 310:	68 2f       	mov	r22, r24
 312:	70 e0       	ldi	r23, 0x00	; 0
 314:	6f 5f       	subi	r22, 0xFF	; 255
 316:	7f 4f       	sbci	r23, 0xFF	; 255
 318:	80 e0       	ldi	r24, 0x00	; 0
 31a:	90 e0       	ldi	r25, 0x00	; 0
void addByteLnBuf( LnBuf *Buffer, byte newByte );
void addMsgLnBuf( LnBuf *Buffer, volatile lnMsg * newMsg );
#else
static inline void addByteLnBuf( LnBuf *Buffer, byte newByte )
{
	Buffer->Buf[ Buffer->WriteIndex++ ] = newByte ;
 31c:	f8 01       	movw	r30, r16
 31e:	e0 58       	subi	r30, 0x80	; 128
 320:	ff 4f       	sbci	r31, 0xFF	; 255
	byte	Index ;
	byte 	Length ;

	Length = getLnMsgSize( newMsg ) ;
	for( Index = 0; Index < Length; Index++ )
		addByteLnBuf(Buffer, newMsg->data[ Index ] ) ;
 322:	de 01       	movw	r26, r28
 324:	a8 0f       	add	r26, r24
 326:	b9 1f       	adc	r27, r25
 328:	4c 91       	ld	r20, X
void addByteLnBuf( LnBuf *Buffer, byte newByte );
void addMsgLnBuf( LnBuf *Buffer, volatile lnMsg * newMsg );
#else
static inline void addByteLnBuf( LnBuf *Buffer, byte newByte )
{
	Buffer->Buf[ Buffer->WriteIndex++ ] = newByte ;
 32a:	30 81       	ld	r19, Z
 32c:	21 e0       	ldi	r18, 0x01	; 1
 32e:	23 0f       	add	r18, r19
 330:	20 83       	st	Z, r18
 332:	d8 01       	movw	r26, r16
 334:	a3 0f       	add	r26, r19
 336:	b1 1d       	adc	r27, r1
 338:	4c 93       	st	X, r20
	if( Buffer->WriteIndex >= LN_BUF_SIZE )
 33a:	22 23       	and	r18, r18
 33c:	0c f4       	brge	.+2      	; 0x340 <__vector_6+0x1ce>
		Buffer->WriteIndex = 0 ;
 33e:	10 82       	st	Z, r1
 340:	01 96       	adiw	r24, 0x01	; 1
{
	byte	Index ;
	byte 	Length ;

	Length = getLnMsgSize( newMsg ) ;
	for( Index = 0; Index < Length; Index++ )
 342:	86 17       	cp	r24, r22
 344:	97 07       	cpc	r25, r23
 346:	69 f7       	brne	.-38     	; 0x322 <__vector_6+0x1b0>

        // Begin CD Backoff state
      lnBitCount = 0 ;
 348:	10 92 81 01 	sts	0x0181, r1	; 0x800181 <lnBitCount>
      lnState = LN_ST_CD_BACKOFF ;      
 34c:	81 e0       	ldi	r24, 0x01	; 1
 34e:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <lnState>
    }
  }

    // Note we may have got here from a failed TX cycle, if so BitCount will be 0
  if( lnState == LN_ST_TX_COLLISION )
 352:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <lnState>
 356:	82 30       	cpi	r24, 0x02	; 2
 358:	c9 f4       	brne	.+50     	; 0x38c <__vector_6+0x21a>
  {
    if( lnBitCount == 0 )
 35a:	80 91 81 01 	lds	r24, 0x0181	; 0x800181 <lnBitCount>
 35e:	81 11       	cpse	r24, r1
 360:	02 c0       	rjmp	.+4      	; 0x366 <__vector_6+0x1f4>
    {
        // Pull the TX Line low to indicate Collision
      LN_SW_UART_SET_TX_LOW
 362:	c1 9a       	sbi	0x18, 1	; 24
 364:	13 c0       	rjmp	.+38     	; 0x38c <__vector_6+0x21a>
#ifdef COLLISION_MONITOR
      cbi( COLLISION_MONITOR_PORT,COLLISION_MONITOR_BIT ) ;
#endif
    }
    else if( lnBitCount >= LN_COLLISION_TICKS )
 366:	80 91 81 01 	lds	r24, 0x0181	; 0x800181 <lnBitCount>
 36a:	8f 30       	cpi	r24, 0x0F	; 15
 36c:	78 f0       	brcs	.+30     	; 0x38c <__vector_6+0x21a>
    {
        // Release the TX Line
      LN_SW_UART_SET_TX_HIGH
 36e:	c1 98       	cbi	0x18, 1	; 24
#ifdef COLLISION_MONITOR
      sbi( COLLISION_MONITOR_PORT,COLLISION_MONITOR_BIT ) ;
#endif

      lnBitCount = 0 ;
 370:	10 92 81 01 	sts	0x0181, r1	; 0x800181 <lnBitCount>
      lnState = LN_ST_CD_BACKOFF ;
 374:	81 e0       	ldi	r24, 0x01	; 1
 376:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <lnState>

      lnRxBuffer->Stats.Collisions++ ;
 37a:	e0 91 7e 01 	lds	r30, 0x017E	; 0x80017e <lnRxBuffer>
 37e:	f0 91 7f 01 	lds	r31, 0x017F	; 0x80017f <lnRxBuffer+0x1>
 382:	e5 57       	subi	r30, 0x75	; 117
 384:	ff 4f       	sbci	r31, 0xFF	; 255
 386:	80 81       	ld	r24, Z
 388:	8f 5f       	subi	r24, 0xFF	; 255
 38a:	80 83       	st	Z, r24
    }
  }

  if( lnState == LN_ST_CD_BACKOFF )
 38c:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <lnState>
 390:	81 30       	cpi	r24, 0x01	; 1
 392:	a1 f4       	brne	.+40     	; 0x3bc <__vector_6+0x24a>
  {
    if( lnBitCount == 0 )
 394:	80 91 81 01 	lds	r24, 0x0181	; 0x800181 <lnBitCount>
 398:	81 11       	cpse	r24, r1
 39a:	07 c0       	rjmp	.+14     	; 0x3aa <__vector_6+0x238>
    {
        // Even though we are waiting, other nodes may try and transmit early
        // so Clear the Start Bit Interrupt Status Flag and Enable ready to 
        // detect the next Start Bit
      sbi( LN_SB_INT_STATUS_REG, LN_SB_INT_STATUS_BIT ) ;
 39c:	88 b7       	in	r24, 0x38	; 56
 39e:	80 62       	ori	r24, 0x20	; 32
 3a0:	88 bf       	out	0x38, r24	; 56
      sbi( LN_SB_INT_ENABLE_REG, LN_SB_INT_ENABLE_BIT ) ;
 3a2:	89 b7       	in	r24, 0x39	; 57
 3a4:	80 62       	ori	r24, 0x20	; 32
 3a6:	89 bf       	out	0x39, r24	; 57
 3a8:	09 c0       	rjmp	.+18     	; 0x3bc <__vector_6+0x24a>
    }
    else if( lnBitCount >= LN_BACKOFF_MAX )
 3aa:	80 91 81 01 	lds	r24, 0x0181	; 0x800181 <lnBitCount>
 3ae:	88 33       	cpi	r24, 0x38	; 56
 3b0:	28 f0       	brcs	.+10     	; 0x3bc <__vector_6+0x24a>
    { // declare network to free after maximum backoff delay
      lnState = LN_ST_IDLE ;
 3b2:	10 92 80 01 	sts	0x0180, r1	; 0x800180 <lnState>
      cbi( LN_TMR_INT_ENABLE_REG, LN_TMR_INT_ENABLE_BIT ) ;
 3b6:	89 b7       	in	r24, 0x39	; 57
 3b8:	8f 7e       	andi	r24, 0xEF	; 239
 3ba:	89 bf       	out	0x39, r24	; 57
    }
  }
}
 3bc:	ff 91       	pop	r31
 3be:	ef 91       	pop	r30
 3c0:	df 91       	pop	r29
 3c2:	cf 91       	pop	r28
 3c4:	bf 91       	pop	r27
 3c6:	af 91       	pop	r26
 3c8:	9f 91       	pop	r25
 3ca:	8f 91       	pop	r24
 3cc:	7f 91       	pop	r23
 3ce:	6f 91       	pop	r22
 3d0:	5f 91       	pop	r21
 3d2:	4f 91       	pop	r20
 3d4:	3f 91       	pop	r19
 3d6:	2f 91       	pop	r18
 3d8:	1f 91       	pop	r17
 3da:	0f 91       	pop	r16
 3dc:	0f 90       	pop	r0
 3de:	0f be       	out	0x3f, r0	; 63
 3e0:	0f 90       	pop	r0
 3e2:	1f 90       	pop	r1
 3e4:	18 95       	reti

000003e6 <initLocoNetHardware>:
  sbi(TX_MEASUREMENT_DDR, TX_MEASUREMENT_PIN);
  cbi(TX_MEASUREMENT_PORT, TX_MEASUREMENT_PIN);
#endif

	
	lnRxBuffer = RxBuffer ;
 3e6:	90 93 7f 01 	sts	0x017F, r25	; 0x80017f <lnRxBuffer+0x1>
 3ea:	80 93 7e 01 	sts	0x017E, r24	; 0x80017e <lnRxBuffer>

    // Set the TX line to Inactive
  LN_SW_UART_SET_TX_HIGH
 3ee:	c1 98       	cbi	0x18, 1	; 24
  sbi( LN_TX_DDR, LN_TX_BIT ) ;
 3f0:	b9 9a       	sbi	0x17, 1	; 23
	ACSR |= (1<<ACBG)|(1<<ACO)|(1<<ACIC);	// turn on comparitor, bandgap, output, input capture
	ADMUX |= (1<<REFS0)|(1<<REFS1)|1;		//choose internal 2.56V source and Chl 1
	TCCR1B = (TCCR1B & 0xF8) | (1<<ICES1) | LN_TMR_PRESCALER ;    		// Set Rising Edge and Timer Clock Source 
#elif (defined wBOARD_FREDI || defined LN_SW_USE_AC_AS_IN_FREDI)
	// Enable Analog Comparator to Trigger the Input Capture unit
	ACSR = (1<<ACI) | (1<<ACIS1) | (1<<ACIS0) | (1<<ACIC) ;
 3f2:	87 e1       	ldi	r24, 0x17	; 23
 3f4:	88 b9       	out	0x08, r24	; 8
    ACSR = 1<<ACD ;
  #endif
//	TCCR1B |= (1<<ICNC1) ;    		// Enable Noise Canceller 
#endif

  lnState = LN_ST_IDLE ;
 3f6:	10 92 80 01 	sts	0x0180, r1	; 0x800180 <lnState>

    //Clear StartBit Interrupt flag
  sbi( LN_SB_INT_STATUS_REG, LN_SB_INT_STATUS_BIT ) ;
 3fa:	88 b7       	in	r24, 0x38	; 56
 3fc:	80 62       	ori	r24, 0x20	; 32
 3fe:	88 bf       	out	0x38, r24	; 56

    //Enable StartBit Interrupt
  sbi( LN_SB_INT_ENABLE_REG, LN_SB_INT_ENABLE_BIT ) ;
 400:	89 b7       	in	r24, 0x39	; 57
 402:	80 62       	ori	r24, 0x20	; 32
 404:	89 bf       	out	0x39, r24	; 57

    // Set Timer Clock Source 
  LN_TMR_CONTROL_REG = (LN_TMR_CONTROL_REG & 0xF8) | LN_TMR_PRESCALER ;
 406:	8e b5       	in	r24, 0x2e	; 46
 408:	88 7f       	andi	r24, 0xF8	; 248
 40a:	81 60       	ori	r24, 0x01	; 1
 40c:	8e bd       	out	0x2e, r24	; 46
 40e:	08 95       	ret

00000410 <sendLocoNetPacketTry>:
}


LN_STATUS sendLocoNetPacketTry(lnMsg *TxData, unsigned char ucPrioDelay)
{
 410:	1f 93       	push	r17
 412:	cf 93       	push	r28
 414:	df 93       	push	r29
 416:	ec 01       	movw	r28, r24
  byte  CheckSum ;
  byte  CheckLength ;

  lnTxLength = getLnMsgSize( TxData ) ;
 418:	16 2f       	mov	r17, r22
 41a:	cb d0       	rcall	.+406    	; 0x5b2 <getLnMsgSize>
 41c:	80 93 7a 01 	sts	0x017A, r24	; 0x80017a <lnTxLength>

  // First calculate the checksum as it may not have been done
  CheckLength = lnTxLength - 1 ;
 420:	20 91 7a 01 	lds	r18, 0x017A	; 0x80017a <lnTxLength>
  CheckSum = 0xFF ;

  for( lnTxIndex = 0; lnTxIndex < CheckLength; lnTxIndex++ )
 424:	21 50       	subi	r18, 0x01	; 1
 426:	10 92 79 01 	sts	0x0179, r1	; 0x800179 <lnTxIndex>
 42a:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <lnTxIndex>
 42e:	82 17       	cp	r24, r18
 430:	90 f4       	brcc	.+36     	; 0x456 <sendLocoNetPacketTry+0x46>
      CheckSum ^= TxData->data[ lnTxIndex ] ;
 432:	9f ef       	ldi	r25, 0xFF	; 255
 434:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <lnTxIndex>
 438:	fe 01       	movw	r30, r28
 43a:	e8 0f       	add	r30, r24
 43c:	f1 1d       	adc	r31, r1
 43e:	80 81       	ld	r24, Z

  // First calculate the checksum as it may not have been done
  CheckLength = lnTxLength - 1 ;
  CheckSum = 0xFF ;

  for( lnTxIndex = 0; lnTxIndex < CheckLength; lnTxIndex++ )
 440:	98 27       	eor	r25, r24
 442:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <lnTxIndex>
 446:	8f 5f       	subi	r24, 0xFF	; 255
 448:	80 93 79 01 	sts	0x0179, r24	; 0x800179 <lnTxIndex>
 44c:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <lnTxIndex>
 450:	82 17       	cp	r24, r18
 452:	80 f3       	brcs	.-32     	; 0x434 <sendLocoNetPacketTry+0x24>

  lnTxLength = getLnMsgSize( TxData ) ;

  // First calculate the checksum as it may not have been done
  CheckLength = lnTxLength - 1 ;
  CheckSum = 0xFF ;
 454:	01 c0       	rjmp	.+2      	; 0x458 <sendLocoNetPacketTry+0x48>

  for( lnTxIndex = 0; lnTxIndex < CheckLength; lnTxIndex++ )
      CheckSum ^= TxData->data[ lnTxIndex ] ;
  
  TxData->data[ CheckLength ] = CheckSum ; 
 456:	9f ef       	ldi	r25, 0xFF	; 255
 458:	fe 01       	movw	r30, r28
 45a:	e2 0f       	add	r30, r18
 45c:	f1 1d       	adc	r31, r1
  // clip maximum prio delay
  if (ucPrioDelay > LN_BACKOFF_MAX)
    ucPrioDelay = LN_BACKOFF_MAX;

  // if priority delay was waited now, declare net as free for this try
  cli();  // disabling interrupt to avoid confusion by ISR changing lnState while we want to do it
 45e:	90 83       	st	Z, r25
  if (lnState == LN_ST_CD_BACKOFF)
 460:	f8 94       	cli
 462:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <lnState>
 466:	81 30       	cpi	r24, 0x01	; 1
  {
    if (lnBitCount >= ucPrioDelay)  // Likely we don't want to wait as long as
 468:	61 f4       	brne	.+24     	; 0x482 <__stack+0x23>
 46a:	80 91 81 01 	lds	r24, 0x0181	; 0x800181 <lnBitCount>
 46e:	19 33       	cpi	r17, 0x39	; 57
 470:	08 f0       	brcs	.+2      	; 0x474 <__stack+0x15>
 472:	18 e3       	ldi	r17, 0x38	; 56
 474:	81 17       	cp	r24, r17
    {                               // the timer ISR waits its maximum delay.
      lnState = LN_ST_IDLE ;
 476:	28 f0       	brcs	.+10     	; 0x482 <__stack+0x23>
 478:	10 92 80 01 	sts	0x0180, r1	; 0x800180 <lnState>
      cbi( LN_TMR_INT_ENABLE_REG, LN_TMR_INT_ENABLE_BIT ) ;
 47c:	89 b7       	in	r24, 0x39	; 57
 47e:	8f 7e       	andi	r24, 0xEF	; 239
    }
  }
  sei();  // a delayed start bit interrupt will happen now,
 480:	89 bf       	out	0x39, r24	; 57
          // a delayed timer interrupt was stalled

  // If the Network is not Idle, don't start the packet
  if (lnState == LN_ST_CD_BACKOFF)
 482:	78 94       	sei
 484:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <lnState>
 488:	81 30       	cpi	r24, 0x01	; 1
  {
    if (lnBitCount < LN_CARRIER_TICKS)   // in carrier detect timer?
 48a:	39 f4       	brne	.+14     	; 0x49a <__stack+0x3b>
 48c:	90 91 81 01 	lds	r25, 0x0181	; 0x800181 <lnBitCount>
      return LN_CD_BACKOFF;
 490:	94 31       	cpi	r25, 0x14	; 20
 492:	08 f0       	brcs	.+2      	; 0x496 <__stack+0x37>
 494:	57 c0       	rjmp	.+174    	; 0x544 <__stack+0xe5>
 496:	80 e0       	ldi	r24, 0x00	; 0
    else
      return LN_PRIO_BACKOFF;
  }

  if( lnState != LN_ST_IDLE )
 498:	55 c0       	rjmp	.+170    	; 0x544 <__stack+0xe5>
 49a:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <lnState>
 49e:	81 11       	cpse	r24, r1
    return LN_NETWORK_BUSY;  // neither idle nor backoff -> busy

  // We need to do this with interrupts off.
  // The last time we check for free net until sending our start bit
  // must be as short as possible, not interrupted.
  cli() ;
 4a0:	4e c0       	rjmp	.+156    	; 0x53e <__stack+0xdf>
  // Before we do anything else - Disable StartBit Interrupt
  cbi( LN_SB_INT_ENABLE_REG, LN_SB_INT_ENABLE_BIT ) ;
 4a2:	f8 94       	cli
 4a4:	89 b7       	in	r24, 0x39	; 57
 4a6:	8f 7d       	andi	r24, 0xDF	; 223
  if (bit_is_set(LN_SB_INT_STATUS_REG, LN_SB_INT_STATUS_BIT))
 4a8:	89 bf       	out	0x39, r24	; 57
 4aa:	08 b6       	in	r0, 0x38	; 56
 4ac:	05 fe       	sbrs	r0, 5
  {
    // first we disabled it, than before sending the start bit, we found out
    // that somebody was faster by examining the start bit interrupt request flag
    sbi( LN_SB_INT_ENABLE_REG, LN_SB_INT_ENABLE_BIT ) ;
 4ae:	06 c0       	rjmp	.+12     	; 0x4bc <__stack+0x5d>
 4b0:	89 b7       	in	r24, 0x39	; 57
 4b2:	80 62       	ori	r24, 0x20	; 32
    sei() ;  // receive now what our rival is sending
 4b4:	89 bf       	out	0x39, r24	; 57
    return LN_NETWORK_BUSY;
 4b6:	78 94       	sei
 4b8:	82 e0       	ldi	r24, 0x02	; 2
  }

  LN_SW_UART_SET_TX_LOW        // Begin the Start Bit
 4ba:	44 c0       	rjmp	.+136    	; 0x544 <__stack+0xe5>
  // added adjustment value for bugfix (Olaf Funke)
#ifdef TX_START_MEASUREMENT
	sbi(TX_MEASUREMENT_PORT, TX_MEASUREMENT_PIN);
#endif
	
  lnCompareTarget = LN_TMR_COUNT_REG + LN_TIMER_TX_RELOAD_PERIOD - LN_TIMER_TX_RELOAD_ADJUST;
 4bc:	c1 9a       	sbi	0x18, 1	; 24
 4be:	8c b5       	in	r24, 0x2c	; 44
 4c0:	9d b5       	in	r25, 0x2d	; 45
 4c2:	85 51       	subi	r24, 0x15	; 21
 4c4:	9d 4f       	sbci	r25, 0xFD	; 253
 4c6:	90 93 7d 01 	sts	0x017D, r25	; 0x80017d <lnCompareTarget+0x1>
 4ca:	80 93 7c 01 	sts	0x017C, r24	; 0x80017c <lnCompareTarget>
  LN_TMR_OUTP_CAPT_REG = lnCompareTarget ;
 4ce:	80 91 7c 01 	lds	r24, 0x017C	; 0x80017c <lnCompareTarget>
 4d2:	90 91 7d 01 	lds	r25, 0x017D	; 0x80017d <lnCompareTarget+0x1>
 4d6:	9b bd       	out	0x2b, r25	; 43

  sei() ;
 4d8:	8a bd       	out	0x2a, r24	; 42

  lnTxData = TxData ;
 4da:	78 94       	sei
 4dc:	d0 93 83 01 	sts	0x0183, r29	; 0x800183 <lnTxData+0x1>
 4e0:	c0 93 82 01 	sts	0x0182, r28	; 0x800182 <lnTxData>
  lnTxIndex = 0 ;
 4e4:	10 92 79 01 	sts	0x0179, r1	; 0x800179 <lnTxIndex>
  lnTxSuccess = 0 ;
 4e8:	10 92 78 01 	sts	0x0178, r1	; 0x800178 <lnTxSuccess>

    // Load the first Byte
  lnCurrentByte = TxData->data[ 0 ] ;
 4ec:	88 81       	ld	r24, Y
 4ee:	80 93 7b 01 	sts	0x017B, r24	; 0x80017b <lnCurrentByte>

    // Set the State to Transmit
  lnState = LN_ST_TX ;                      
 4f2:	83 e0       	ldi	r24, 0x03	; 3
 4f4:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <lnState>

    // Reset the bit counter
  lnBitCount = 0 ;                          
 4f8:	10 92 81 01 	sts	0x0181, r1	; 0x800181 <lnBitCount>

    // Clear the current Compare interrupt status bit and enable the Compare interrupt
  sbi(LN_TMR_INT_STATUS_REG, LN_TMR_INT_STATUS_BIT) ;
 4fc:	88 b7       	in	r24, 0x38	; 56
 4fe:	80 61       	ori	r24, 0x10	; 16
  sbi(LN_TMR_INT_ENABLE_REG, LN_TMR_INT_ENABLE_BIT) ; 
 500:	88 bf       	out	0x38, r24	; 56
 502:	89 b7       	in	r24, 0x39	; 57
 504:	80 61       	ori	r24, 0x10	; 16

  // now busy waiting until the interrupts did the rest
  while (lnState == LN_ST_TX) {}
 506:	89 bf       	out	0x39, r24	; 57
 508:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <lnState>
 50c:	83 30       	cpi	r24, 0x03	; 3

  if (lnTxSuccess)
 50e:	e1 f3       	breq	.-8      	; 0x508 <__stack+0xa9>
 510:	80 91 78 01 	lds	r24, 0x0178	; 0x800178 <lnTxSuccess>
 514:	88 23       	and	r24, r24
  {
    lnRxBuffer->Stats.TxPackets++ ;
 516:	69 f0       	breq	.+26     	; 0x532 <__stack+0xd3>
 518:	e0 91 7e 01 	lds	r30, 0x017E	; 0x80017e <lnRxBuffer>
 51c:	f0 91 7f 01 	lds	r31, 0x017F	; 0x80017f <lnRxBuffer+0x1>
 520:	e8 57       	subi	r30, 0x78	; 120
 522:	ff 4f       	sbci	r31, 0xFF	; 255
 524:	80 81       	ld	r24, Z
 526:	91 81       	ldd	r25, Z+1	; 0x01
 528:	01 96       	adiw	r24, 0x01	; 1
 52a:	91 83       	std	Z+1, r25	; 0x01
    return LN_DONE;
 52c:	80 83       	st	Z, r24
 52e:	83 e0       	ldi	r24, 0x03	; 3
  }

  if (lnState == LN_ST_TX_COLLISION)
 530:	09 c0       	rjmp	.+18     	; 0x544 <__stack+0xe5>
 532:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <lnState>
 536:	82 30       	cpi	r24, 0x02	; 2
  {
    return LN_COLLISION;
  }

  return LN_UNKNOWN_ERROR; // everything else is an error
 538:	21 f0       	breq	.+8      	; 0x542 <__stack+0xe3>
 53a:	85 e0       	ldi	r24, 0x05	; 5
    else
      return LN_PRIO_BACKOFF;
  }

  if( lnState != LN_ST_IDLE )
    return LN_NETWORK_BUSY;  // neither idle nor backoff -> busy
 53c:	03 c0       	rjmp	.+6      	; 0x544 <__stack+0xe5>
 53e:	82 e0       	ldi	r24, 0x02	; 2
    return LN_DONE;
  }

  if (lnState == LN_ST_TX_COLLISION)
  {
    return LN_COLLISION;
 540:	01 c0       	rjmp	.+2      	; 0x544 <__stack+0xe5>
  }

  return LN_UNKNOWN_ERROR; // everything else is an error
}
 542:	84 e0       	ldi	r24, 0x04	; 4
 544:	df 91       	pop	r29
 546:	cf 91       	pop	r28
 548:	1f 91       	pop	r17
 54a:	08 95       	ret

0000054c <__vector_9>:
volatile byte SlowTimerTicks = 0 ;
volatile byte FastTimerTicks = 0 ;
volatile word DelayTimerTicks = 0 ;

ISR(TIMER0_OVF_vect)
{
 54c:	1f 92       	push	r1
 54e:	0f 92       	push	r0
 550:	0f b6       	in	r0, 0x3f	; 63
 552:	0f 92       	push	r0
 554:	11 24       	eor	r1, r1
 556:	8f 93       	push	r24
 558:	9f 93       	push	r25
  TCNT0 = (byte) TICK_RELOAD ;
 55a:	82 ec       	ldi	r24, 0xC2	; 194
 55c:	82 bf       	out	0x32, r24	; 50

  FastTimerTicks++;
 55e:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <FastTimerTicks>
 562:	8f 5f       	subi	r24, 0xFF	; 255
 564:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <FastTimerTicks>

  if( ++SlowTimerAccumulator >= 100 )
 568:	80 91 65 00 	lds	r24, 0x0065	; 0x800065 <SlowTimerAccumulator>
 56c:	8f 5f       	subi	r24, 0xFF	; 255
 56e:	84 36       	cpi	r24, 0x64	; 100
 570:	18 f4       	brcc	.+6      	; 0x578 <__vector_9+0x2c>
 572:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <SlowTimerAccumulator>
 576:	07 c0       	rjmp	.+14     	; 0x586 <__vector_9+0x3a>
  {
    SlowTimerAccumulator = 0 ;
 578:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <SlowTimerAccumulator>

    SlowTimerTicks++;
 57c:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <SlowTimerTicks>
 580:	8f 5f       	subi	r24, 0xFF	; 255
 582:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <SlowTimerTicks>
  }
	
	if( DelayTimerTicks )
 586:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <DelayTimerTicks>
 58a:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <DelayTimerTicks+0x1>
 58e:	89 2b       	or	r24, r25
 590:	49 f0       	breq	.+18     	; 0x5a4 <__vector_9+0x58>
		DelayTimerTicks--;
 592:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <DelayTimerTicks>
 596:	90 91 62 00 	lds	r25, 0x0062	; 0x800062 <DelayTimerTicks+0x1>
 59a:	01 97       	sbiw	r24, 0x01	; 1
 59c:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <DelayTimerTicks+0x1>
 5a0:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <DelayTimerTicks>
}
 5a4:	9f 91       	pop	r25
 5a6:	8f 91       	pop	r24
 5a8:	0f 90       	pop	r0
 5aa:	0f be       	out	0x3f, r0	; 63
 5ac:	0f 90       	pop	r0
 5ae:	1f 90       	pop	r1
 5b0:	18 95       	reti

000005b2 <getLnMsgSize>:
{
	return 0 ;
}

byte getLnMsgSize( volatile lnMsg * Msg )
{
 5b2:	fc 01       	movw	r30, r24
	return ( ( Msg->sz.command & (byte)0x60 ) == (byte)0x60 ) ? Msg->sz.mesg_size : ( ( Msg->sz.command & (byte)0x60 ) >> (byte)4 ) + 2 ;
 5b4:	90 81       	ld	r25, Z
 5b6:	90 76       	andi	r25, 0x60	; 96
 5b8:	90 36       	cpi	r25, 0x60	; 96
 5ba:	11 f4       	brne	.+4      	; 0x5c0 <getLnMsgSize+0xe>
 5bc:	81 81       	ldd	r24, Z+1	; 0x01
 5be:	08 95       	ret
 5c0:	80 81       	ld	r24, Z
 5c2:	80 76       	andi	r24, 0x60	; 96
 5c4:	82 95       	swap	r24
 5c6:	8f 70       	andi	r24, 0x0F	; 15
 5c8:	8e 5f       	subi	r24, 0xFE	; 254
}
 5ca:	08 95       	ret

000005cc <initLocoNet>:
  SendPacket.data[ 0 ] = OpCode ;
  SendPacket.data[ 1 ] = Data1 ;
  SendPacket.data[ 2 ] = Data2 ;

  return sendLocoNetPacket( &SendPacket ) ;
}
 5cc:	90 93 67 00 	sts	0x0067, r25	; 0x800067 <pstLnRxBuffer+0x1>
 5d0:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <pstLnRxBuffer>
 5d4:	08 cf       	rjmp	.-496    	; 0x3e6 <initLocoNetHardware>
 5d6:	08 95       	ret

000005d8 <sendLocoNet4BytePacketTry>:

LN_STATUS sendLocoNet4BytePacketTry( byte OpCode, byte Data1, byte Data2, byte PrioDelay )
{
 5d8:	cf 93       	push	r28
 5da:	df 93       	push	r29
 5dc:	cd b7       	in	r28, 0x3d	; 61
 5de:	de b7       	in	r29, 0x3e	; 62
 5e0:	63 97       	sbiw	r28, 0x13	; 19
 5e2:	0f b6       	in	r0, 0x3f	; 63
 5e4:	f8 94       	cli
 5e6:	de bf       	out	0x3e, r29	; 62
 5e8:	0f be       	out	0x3f, r0	; 63
 5ea:	cd bf       	out	0x3d, r28	; 61
  lnMsg SendPacket ;

  SendPacket.data[ 0 ] = OpCode ;
 5ec:	89 83       	std	Y+1, r24	; 0x01
  SendPacket.data[ 1 ] = Data1 ;
 5ee:	6a 83       	std	Y+2, r22	; 0x02
  SendPacket.data[ 2 ] = Data2 ;
 5f0:	4b 83       	std	Y+3, r20	; 0x03

  return sendLocoNetPacketTry( &SendPacket, PrioDelay ) ;
 5f2:	62 2f       	mov	r22, r18
 5f4:	ce 01       	movw	r24, r28
 5f6:	01 96       	adiw	r24, 0x01	; 1
 5f8:	0b df       	rcall	.-490    	; 0x410 <sendLocoNetPacketTry>
}
 5fa:	63 96       	adiw	r28, 0x13	; 19
 5fc:	0f b6       	in	r0, 0x3f	; 63
 5fe:	f8 94       	cli
 600:	de bf       	out	0x3e, r29	; 62
 602:	0f be       	out	0x3f, r0	; 63
 604:	cd bf       	out	0x3d, r28	; 61
 606:	df 91       	pop	r29
 608:	cf 91       	pop	r28
 60a:	08 95       	ret

0000060c <_exit>:
 60c:	f8 94       	cli

0000060e <__stop_program>:
 60e:	ff cf       	rjmp	.-2      	; 0x60e <__stop_program>
